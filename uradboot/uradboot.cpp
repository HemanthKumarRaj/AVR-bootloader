#include <avr/boot.h>
#include <util/delay.h>
#include <avr/interrupt.h>

uint8_t prog[] = {
		0x0C,0x94,0x46,0x00,0x0C,0x94,0x50,0x00,0x0C,0x94,0x50,0x00,0x0C,0x94,0x50,0x00, // 16 bytes
		0x0C,0x94,0x50,0x00,0x0C,0x94,0x50,0x00,0x0C,0x94,0x50,0x00,0x0C,0x94,0x50,0x00,
		0x0C,0x94,0x50,0x00,0x0C,0x94,0x50,0x00,0x0C,0x94,0x50,0x00,0x0C,0x94,0x50,0x00,
		0x0C,0x94,0x50,0x00,0x0C,0x94,0x50,0x00,0x0C,0x94,0x50,0x00,0x0C,0x94,0x50,0x00,
		0x0C,0x94,0x50,0x00,0x0C,0x94,0x50,0x00,0x0C,0x94,0x50,0x00,0x0C,0x94,0x50,0x00,
		0x0C,0x94,0x50,0x00,0x0C,0x94,0x50,0x00,0x0C,0x94,0x50,0x00,0x0C,0x94,0x50,0x00,
		0x0C,0x94,0x50,0x00,0x0C,0x94,0x50,0x00,0x0C,0x94,0x50,0x00,0x0C,0x94,0x50,0x00,
		0x0C,0x94,0x50,0x00,0x0C,0x94,0x50,0x00,0x0C,0x94,0x50,0x00,0x0C,0x94,0x50,0x00, //128

		0x0C,0x94,0x50,0x00,0x0C,0x94,0x50,0x00,0x0C,0x94,0x50,0x00,0x11,0x24,0x1F,0xBE,
		0xCF,0xEF,0xD0,0xE4,0xDE,0xBF,0xCD,0xBF,0x0E,0x94,0x52,0x00,0x0C,0x94,0x65,0x00,
		0x0C,0x94,0x00,0x00,0x54,0x9A,0x5C,0x9A,0x8F,0xE0,0x97,0xE2,0x01,0x97,0xF1,0xF7,
		0x00,0xC0,0x00,0x00,0x5C,0x98,0x9F,0xEF,0x29,0xE6,0x88,0xE1,0x91,0x50,0x20,0x40,
		0x80,0x40,0xE1,0xF7,0x00,0xC0,0x00,0x00,0xEE,0xCF,0xF8,0x94,0xFF,0xCF,0xFF,0xFF,
		0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
		0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
		0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
};

void boot_program_page (uint32_t page, uint8_t *buf)
{
	uint16_t i;
	uint8_t sreg;

	// Disable interrupts.

	sreg = SREG;
	cli();

	eeprom_busy_wait ();

	boot_page_erase (page);
	boot_spm_busy_wait ();      // Wait until the memory is erased.

	for (i=0; i<SPM_PAGESIZE; i+=2)
	{
		// Set up little-endian word.

		uint16_t w = *buf++;
		w += (*buf++) << 8;

		boot_page_fill (page + i, w);
	}

	boot_page_write (page);     // Store buffer in flash page.
	boot_spm_busy_wait();       // Wait until the memory is written.

	// Reenable RWW-section again. We need this if we want to jump back
	// to the application after bootloading.

	boot_rww_enable ();

	// Re-enable interrupts (if they were ever enabled).

	SREG = sreg;
}

int main(void) {
	// long beep in bootloader
	DDRD |= 1 << PD4;
	PORTD |= 1 << PD4;
	_delay_ms(100);
	PORTD &= ~(1 << PD4);
	_delay_ms(1000);

	//start at flash_start = 0x0000
	boot_program_page( 0, prog);

	//start the actual program
	asm("jmp 0");

	// bootloader ends here

}
